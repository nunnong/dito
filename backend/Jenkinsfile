pipeline {
  agent any

  environment {
    // ====== 기본 설정 ======
    BACKEND_DIR     = 'backend'
    COMPOSE_FILE    = "${env.BACKEND_DIR}/docker-compose.yml"

    // ====== 이미지 태깅 전략 ======
    IMAGE_NAME      = 'dito-backend'
    BUILD_TAG       = "build-${env.BUILD_NUMBER}"
    STABLE_TAG      = 'latest-stable'
    DOCKER_IMAGE    = "${IMAGE_NAME}:${BUILD_TAG}"
  }

  options {
    buildDiscarder(logRotator(numToKeepStr: '10'))
    timeout(time: 30, unit: 'MINUTES')
    disableConcurrentBuilds()
    timestamps()
  }

  stages {

    stage('Prepare') {
      steps {
        script {
          echo '========================================='
          echo "Starting CI/CD Pipeline"
          echo "Build #${env.BUILD_NUMBER}"
          echo "Branch: ${env.GIT_BRANCH ?: 'N/A'}"
          echo '========================================='
        }
        deleteDir()
      }
    }

    stage('Checkout') {
      steps {
        echo "Checking out source from SCM..."
        checkout scm
        sh '''
          echo "Current directory: $(pwd)"
          echo "Git branch: $(git rev-parse --abbrev-ref HEAD)"
          echo "Git commit: $(git rev-parse --short HEAD)"
        '''
      }
    }

    stage('Environment Setup') {
      steps {
        echo 'Injecting secret env file...'
        script {
          withCredentials([file(credentialsId: 'dito-backend-env', variable: 'ENV_FILE')]) {
            sh '''#!/bin/bash -e
              echo "Copying .env file..."
              cp "$ENV_FILE" "$BACKEND_DIR/.env"
              chmod 600 "$BACKEND_DIR/.env"

              # Windows CRLF를 Unix LF로 변환
              echo "Converting line endings (CRLF -> LF)..."
              sed -i 's/\r$//' "$BACKEND_DIR/.env"

              echo "✓ Environment file ready"
            '''
          }
        }
      }
    }

    stage('Build JAR') {
      steps {
        dir("${BACKEND_DIR}/Dito") {  // gradlew가 있는 경로로 이동
          sh '''
            echo "Building jar file..."
            chmod +x gradlew
            ./gradlew clean build -x test
          '''
        }
      }
    }

    stage('Build Docker Image') {
      steps {
        dir("${BACKEND_DIR}") {
          sh '''#!/bin/bash -e
            echo "Built artifacts:"
            ls -al Dito/build/libs || true

            echo "Picking Spring Boot fat jar (exclude *-plain.jar)..."
            JAR_PATH=$(ls Dito/build/libs/*-SNAPSHOT.jar | grep -v -- "-plain.jar" | head -n1)

            if [ -z "$JAR_PATH" ] || [ ! -f "$JAR_PATH" ]; then
              echo "Boot JAR not found in Dito/build/libs (fat jar)"
              exit 1
            fi

            echo "Copying $JAR_PATH -> app.jar"
            cp "$JAR_PATH" ./app.jar
            chmod 644 ./app.jar

            echo "Building Docker image: ${DOCKER_IMAGE}..."
            docker build -t "${DOCKER_IMAGE}" .

            echo "Image built successfully!"
            docker images | grep "${IMAGE_NAME}" | head -5
          '''
        }
      }
    }

    stage('Deploy with Zero Downtime') {
      steps {
        dir("${BACKEND_DIR}") {
          script {
            sh '''#!/bin/bash -e
              echo "========================================="
              echo "Starting Zero-Downtime Deployment (Blue-Green)"
              echo "New Image: ${DOCKER_IMAGE}"
              echo "========================================="

              # 기존 컨테이너 확인
              OLD_CONTAINER=$(docker ps -q -f name=dito-app) || true

              if [ -n "$OLD_CONTAINER" ]; then
                echo "Found existing container: $OLD_CONTAINER"
                echo "Will keep it running until new container is healthy..."
              else
                echo "No existing container found. First deployment."
              fi

              # 이전 실패한 임시 컨테이너 정리
              echo "Cleaning up any previous failed deployment..."
              docker rm -f dito-app-new 2>/dev/null || true

              # 새 컨테이너를 임시 이름으로 시작 (dito-app-new)
              echo "Starting new container as 'dito-app-new' with image: ${DOCKER_IMAGE}..."

              docker run -d \
                --name dito-app-new \
                --network dito-network \
                --env-file .env \
                -e SPRING_DATASOURCE_URL="jdbc:postgresql://dito-postgres:5432/${DB_NAME:-dito}" \
                -e SPRING_DATASOURCE_USERNAME="${DB_USER:-dito}" \
                -e SPRING_DATASOURCE_PASSWORD="${DB_PASSWORD:-dito2025}" \
                -e SPRING_DATA_REDIS_HOST=dito-redis \
                -e SPRING_DATA_REDIS_PORT=6379 \
                -e SPRING_DATA_REDIS_PASSWORD="${REDIS_PASSWORD:-dito2025}" \
                -e EXTERNALS_REDIS_HOST=dito-redis \
                -e EXTERNALS_REDIS_PORT=6379 \
                -e EXTERNALS_REDIS_PASSWORD="${REDIS_PASSWORD:-dito2025}" \
                -e SPRING_JPA_HIBERNATE_DDL_AUTO="${DDL_AUTO:-validate}" \
                -e SPRING_JPA_SHOW_SQL="${SHOW_SQL:-false}" \
                -e SPRING_FLYWAY_ENABLED="${FLYWAY_ENABLED:-true}" \
                -e SPRING_PROFILES_ACTIVE="${SPRING_PROFILE:-prod}" \
                -e SERVER_PORT=8080 \
                -e JWT_SECRET="${JWT_SECRET}" \
                -e JWT_ACCESS_EXPIRATION=604800000 \
                -e JWT_REFRESH_EXPIRATION=604800000 \
                -e LOGGING_LEVEL_ROOT="${LOG_LEVEL:-INFO}" \
                -e LOGGING_LEVEL_COM_SSAFY="${APP_LOG_LEVEL:-DEBUG}" \
                -p 8081:8080 \
                --restart unless-stopped \
                --health-cmd="wget --quiet --tries=1 --spider http://localhost:8080/actuator/health || exit 1" \
                --health-interval=10s \
                --health-timeout=5s \
                --health-retries=10 \
                --health-start-period=60s \
                "${DOCKER_IMAGE}"

              echo "New container started. Container will be validated in next stage..."
              echo "Old container is still serving traffic."
            '''
          }
        }
      }
    }



    stage('Health Check & Swap') {
      steps {
        script {
          try {
            dir("${BACKEND_DIR}") {
              sh '''#!/bin/bash -e
                echo "========================================="
                echo "Validating New Container Health"
                echo "========================================="

                # 1. Docker healthcheck가 healthy가 될 때까지 대기 (최대 120초)
                echo "Waiting for Docker healthcheck to become healthy..."
                TIMEOUT=120
                ELAPSED=0

                while [ $ELAPSED -lt $TIMEOUT ]; do
                  HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' dito-app-new 2>/dev/null || echo "none")

                  echo "[${ELAPSED}s] Container health status: $HEALTH_STATUS"

                  if [ "$HEALTH_STATUS" = "healthy" ]; then
                    echo "✓ Container is healthy!"
                    break
                  elif [ "$HEALTH_STATUS" = "unhealthy" ]; then
                    echo "✗ Container is unhealthy. Check logs below:"
                    docker logs --tail=100 dito-app-new
                    exit 1
                  fi

                  sleep 5
                  ELAPSED=$((ELAPSED + 5))
                done

                if [ $ELAPSED -ge $TIMEOUT ]; then
                  echo "✗ Health check timeout after ${TIMEOUT}s"
                  echo "Container logs:"
                  docker logs --tail=100 dito-app-new
                  exit 1
                fi

                # 2. 추가 HTTP health check (포트 8081)
                echo ""
                echo "Performing additional HTTP health check on port 8081..."

                MAX_ATTEMPTS=10
                for i in $(seq 1 $MAX_ATTEMPTS); do
                  CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:8081/actuator/health" || echo "000")

                  if [ "$CODE" = "200" ] || [ "$CODE" = "403" ]; then
                    echo "✓ HTTP health check passed with status $CODE"
                    break
                  else
                    echo "Attempt $i/$MAX_ATTEMPTS: HTTP $CODE, retrying..."
                    if [ $i -eq $MAX_ATTEMPTS ]; then
                      echo "✗ HTTP health check failed after $MAX_ATTEMPTS attempts"
                      exit 1
                    fi
                    sleep 5
                  fi
                done

                echo ""
                echo "========================================="
                echo "✓ All health checks passed!"
                echo "Swapping containers..."
                echo "========================================="

                # 3. 기존 컨테이너 중지 및 제거
                OLD_CONTAINER=$(docker ps -q -f name=dito-app) || true
                if [ -n "$OLD_CONTAINER" ]; then
                  echo "Stopping old container: $OLD_CONTAINER"
                  docker stop dito-app || true
                  docker rm dito-app || true
                fi

                # 4. 새 컨테이너 중지 및 제거
                echo "Stopping temporary container dito-app-new..."
                docker stop dito-app-new || true
                docker rm dito-app-new || true

                # 5. Docker Compose로 정식 컨테이너 시작
                echo "Starting production container with docker-compose..."
                export APP_IMAGE="${DOCKER_IMAGE}"
                docker compose --env-file .env -f docker-compose.yml up -d app

                # 6. 최종 확인
                echo ""
                echo "Waiting for production container to be ready..."
                sleep 10

                FINAL_STATUS=$(docker inspect --format='{{.State.Health.Status}}' dito-app 2>/dev/null || echo "starting")
                echo "Production container status: $FINAL_STATUS"

                echo ""
                echo "========================================="
                echo "✓ Deployment Successful!"
                echo "========================================="
              '''
            }
            echo "Health check and container swap completed successfully!"
          } catch (Exception e) {
            echo "Health check failed! Rolling back..."
            dir("${BACKEND_DIR}") {
              sh '''#!/bin/bash
                echo "========================================="
                echo "✗ HEALTH CHECK FAILED - ROLLING BACK"
                echo "========================================="

                # 실패한 새 컨테이너 로그 출력
                echo "Failed container logs:"
                docker logs --tail=100 dito-app-new 2>/dev/null || echo "No logs available"

                # 새 컨테이너만 제거 (기존 컨테이너는 유지!)
                echo ""
                echo "Removing failed container dito-app-new..."
                docker rm -f dito-app-new 2>/dev/null || true

                # 기존 컨테이너 상태 확인
                OLD_CONTAINER=$(docker ps -q -f name=dito-app) || true
                if [ -n "$OLD_CONTAINER" ]; then
                  echo "✓ Old container (dito-app) is still running"
                  echo "Service is not interrupted!"
                else
                  echo "⚠ No running container found!"
                  echo "Attempting to start with latest-stable image..."

                  STABLE_IMAGE="${IMAGE_NAME}:${STABLE_TAG}"
                  if docker image inspect "$STABLE_IMAGE" >/dev/null 2>&1; then
                    echo "Starting container with stable image: $STABLE_IMAGE"
                    export APP_IMAGE="$STABLE_IMAGE"
                    docker compose -f docker-compose.yml up -d app
                    echo "✓ Service restored with previous stable version"
                  else
                    echo "✗ No stable image found. Manual intervention required!"
                  fi
                fi

                echo ""
                echo "========================================="
                echo "Rollback completed"
                echo "========================================="
              '''
            }
            error("Deployment failed. Old container preserved, new container removed.")
          }
        }
      }
    }

    stage('Tag Stable Image') {
      steps {
        dir("${BACKEND_DIR}") {
          sh '''#!/bin/bash -e
            echo "========================================="
            echo "Tagging successful deployment as stable"
            echo "========================================="

            # 새 이미지를 latest-stable로 태깅
            docker tag "${DOCKER_IMAGE}" "${IMAGE_NAME}:${STABLE_TAG}"

            echo "Tagged ${DOCKER_IMAGE} as ${IMAGE_NAME}:${STABLE_TAG}"
            echo "This image will be used for rollback if future deployments fail."

            # 이미지 목록 확인
            echo ""
            echo "Available images:"
            docker images | grep "${IMAGE_NAME}" | head -10
          '''
        }
      }
    }

    stage('Cleanup') {
      steps {
        dir("${BACKEND_DIR}") {
          sh '''#!/bin/bash
            echo "Cleaning up old images..."

            # 최근 3개 빌드 이미지만 유지 (build-N 태그)
            echo "Keeping latest 3 build images and stable image..."
            docker images "${IMAGE_NAME}" --format "{{.Tag}}" | grep "^build-" | sort -t- -k2 -rn | tail -n +4 | while read tag; do
              echo "Removing old image: ${IMAGE_NAME}:$tag"
              docker rmi "${IMAGE_NAME}:$tag" || true
            done

            # dangling 이미지 정리
            docker image prune -f || true

            echo ""
            echo "Remaining images:"
            docker images | grep "${IMAGE_NAME}" || echo "No images found"
          '''
        }
      }
    }
  }

  post {
    success {
      echo '========================================='
      echo "CI/CD Pipeline completed successfully!"
      echo '========================================='
      dir("${BACKEND_DIR}") {
        sh '''
          echo "Deployment Info"
          echo "  Image: ${DOCKER_IMAGE}"
          echo "  Stable: ${IMAGE_NAME}:${STABLE_TAG}"
          echo "  Build: #${BUILD_NUMBER}"
          echo "  Time : $(date)"
          echo ""
          echo "Running containers:"
          docker compose -f docker-compose.yml ps
        '''
      }
    }
    failure {
      echo '========================================='
      echo "CI/CD Pipeline failed!"
      echo '========================================='
      dir("${BACKEND_DIR}") {
        sh '''
          echo "Failed at build #${BUILD_NUMBER}"
          echo "Attempted image: ${DOCKER_IMAGE}"
          echo ""
          echo "Container status:"
          docker compose -f docker-compose.yml ps || true
          echo ""
          echo "Recent logs:"
          docker compose -f docker-compose.yml logs --tail=100 || true
          echo ""
          echo "Available images:"
          docker images | grep "${IMAGE_NAME}" || echo "No images found"
        '''
      }
    }
    always {
      echo 'Finalizing...'
//       sh "rm -f ${BACKEND_DIR}/.env || true"
    }
  }
}
